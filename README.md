# WordCluster

## Архитектура проекта

### Общая структура
Архитектура построена по принципу **MVP (Model–View–Presenter)** с паттерном **Passive View**:
- **Model**  
  - `BoardState` — ядро игрового состояния. Хранит текущее расположение кластеров, проверяет валидность слов, фиксирует порядок разгаданных слов.  
  - `LevelData` — храненилище данных уровня (загружается из JSON).  
  - `ProgressService` — хранение прогресса игрока в `PlayerPrefs`.
- **View**  
  - Все `*View` классы (`GameView`, `WinView`, `MainMenuView`) унаследованы от `MonoBehaviour`.  
  - Passive View: не содержит бизнес-логики, только визуализация и события ввода.  
  - `GameView` управляет гридом ячеек и динамическими префабами кластеров.  
  - Также имеется дэбажная кнопка `"W"` в левом верхнем углу завершает уровень сразу.
- **Presenter**  
  - `GamePresenter`, `WinPresenter`, `MainMenuPresenter` обрабатывают ввод от View, управляют состоянием модели, вызывают обновления интерфейса.  
  - `GamePresenter` отвечает за игровой процесс и проверку слов.  
  - `WinPresenter` выводит список разгаданных слов.  
  - `MainMenuPresenter` управляет запуском уровней.

### Точка входа
Точка входа — `GameApp`.  
Она регистрирует сервисы (репозиторий уровней, прогресс, сервис порядка слов и др.) и управляет показом экранов через `ScreenController`.

### ServiceRegistry и Services

В проекте реализован собственный облегчённый механизм сервис-локатора:  
- `ServiceRegistry` хранит зависимости в словаре `Dictionary<Type, object>`.  
- `Services` — статический фасад, позволяющий быстро получить зарегистрированные сервисы (`Services.Get<T>()`).  
- Сервисы регистрируются один раз в `GameApp` при старте (репозиторий уровней, прогресс, сервис порядка слов и т.п.).  

Я сознательно **не использую DI-фреймворки вроде Zenject**, так как для маленькой игры это было бы избыточным и утяжелило бы код (не хочется тащить с собой что-то тяжеловесное в билд, что использоваться не будет и может в целом конфликтовать при билде между собой).  
Собственная реализация:  
- даёт ту же гибкость (подмена сервисов, тестирование),  
- но остаётся простой и прозрачной,  
- полностью соответствует принципу **KISS**.  

### Управление экранами
Используется собственный **ScreenController**:  
- Экономия ресурсов: на сцене одновременно присутствуют все основные UI-экраны.  
- Переключение происходит через **кэширование** — экраны активируются/деактивируются, а не пересоздаются.  
- Это упрощает логику и ускоряет переключение экранов.

### Конфигурация уровней
- Уровни хранятся в JSON (`Resources/levels.json`).  
- Каждый уровень описан: `Id`, `Layout` (размер поля), список слов и список кластеров.  
- В `UiOptions` можно указать, например, `ShuffleClusters`, чтобы кластеры перемешивались при отображении.  
- Благодаря абстракции `ILevelRepository`, источник данных легко заменить на загрузку с сервера.

### Кластеры и префаб-варианты
- Для кластеров используются **Prefab Variants**: `Cluster_1`, `Cluster_2`, `Cluster_3` и т.д.  
- Это нужно, потому что кластеры бывают разной длины, а настраивать через код - не наглядно (от 1 до нескольких букв).  
- Внутри рамки буквы создаются динамически (`LetterItem` prefab).  
- Расстояние между буквами в кластере совпадает с расстоянием между ячейками поля.

### Почему без сторонних фреймворков?
- Для чистоты тестового задания и прозрачности архитектуры.  
- Unity UI + стандартные MonoBehaviour + минимальные собственные сервисы → достаточно для задач MVP такого плана игр.  
- Это упрощает чтение кода и снижает порог вхождения для любого разработчика.

---

## Расширяемость

### 1. Система загрузки уровней
> Задача: заменить загрузку уровней из JSON на асинхронную загрузку с сервера.  

- Текущая реализация использует `ILevelRepository`.  
- Нужно лишь заменить его реализацию (`JsonLevelRepository` → `ServerLevelRepository`).  
- Остальной код (Presenter, BoardState, Views) останется неизменным.  
**Стоимость доработки: минимальная (меняется только репозиторий).**

---

### 2. Расширяемость геймплея
> Задача: сделать режим со словами длиной 8 букв.  

- Размер слова задаётся в `LevelData.Layout.WordLength`.  
- `BoardState` и `GameView.BuildGrid` динамически учитывают это значение.  
- Дополнительно нужно создать новый **Prefab Variant** для кластеров нужного размера (если появятся более длинные кластеры).  
**Стоимость доработки: минимальная (только настройка данных + новые префабы при необходимости).**

---

### 3. Заменяемость геймплея
> Задача: заменить сам игровой процесс, но оставить систему загрузки уровней, прогресс и интерфейс.  

- Бизнес-логика инкапсулирована в `BoardState` и `GamePresenter`.  
- При замене геймплея можно реализовать новый Presenter и модель, оставив:  
  - `ILevelRepository` (загрузка уровней),  
  - `ProgressService` (прогресс),  
  - `ScreenController` (навигация между экранами),  
  - UI (меню, экран победы).  
**Стоимость доработки: переписывается только часть, связанная с новой логикой, остальные подсистемы сохраняются.**

---

# Использование GPT-5
При создании MVP повсеместно использовалась LLM модель GPT-5.  
Сам я постоянно в работе использую эту LLM модель уже более 3х лет, и с ней на "ты" (Использую, кстати, не только в работе но и по "житейским" вопросам — медицина, кулинария, фотография, спорт и т.д.).  

**Пайплайн использования:**  
- Я сам продумываю архитектуру, выбираю подходящие правила  
- GPT рисует код  
- Я вношу правки на словах: что нравится, что считаю лишним  
- GPT правит код  
- Я вставляю код и проверяю сам  

Некоторые классы (такие как **JsonLevelRepository**) написаны целиком GPT.  
Большая часть бизнес-логики написана тоже GPT для экономии времени.  
Даже этот Readme в основном написан GPT.  

## Примечание
В проекте есть места, где можно было бы закэшировать некоторые сущности внутри кода (а не каждый раз дерать например GetComponentInChildren), местами я умышленно не кэшировал некоторые вещи, тк считаю что для быстрой разработки MVP это местами избыточно,
и бороться за 1.5мб аллокаций в оперативной памяти нету смысла. Но на всякий случай показал кэширование панелей в классе **ScreenController**.


